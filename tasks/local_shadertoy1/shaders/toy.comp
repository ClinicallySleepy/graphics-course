#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

float uTime = 0.1;

float sphere (in vec3 p, float r)
{
    return (length (p) - r);
}

// still have troubles with implementing nice floor with this
float plane ( in vec3 p, vec4 n )
{
    return dot ( p, n.xyz ) + n.w;
}

float box ( in vec3 pos, in vec3 size )
{
    vec3 pt = abs ( 1. * pos ) - size;

    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );
}

vec3 getTriplanarWeights ( in vec3 n )
{
    vec3 w = abs ( n );

    w *= w;

    return w / ( w.x + w.y + w.z );
}

mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, -s, 0),
        vec3(s, c, 0),
        vec3(0, 0, 1)
    );
}

// not good :(
//float noisySphere (in vec3 p, vec2 uv, float r)
//{
//    // vec4 color = texture(iChannel0, uv * 0.5);
//    vec4 color = texture(iChannel1, p.xy * 5.);
//    // return (length (p + color.rgb * 0.01) - 0.2);
//    return (length (p) - (r + color.r * 0.01) * 0.8);
//}

// still not good
//#define PI 3.1415
//float noisySphere(in vec3 p, vec2 uv, float r) {
//   float longtitude = atan(p[1], p[0]);
//   float latitude = asin(p[2]/r);
//   float nlongtitude = longtitude/(2. * PI) + 0.5;
//   float nlatitude = latitude/PI + 0.5;  
//   vec4 color = texture(iChannel1, vec2(nlongtitude, nlatitude) * 5.);
//    // return (length (p + color.rgb * 0.01) - 0.2);
//    return (length (p) - (r + color.r * 0.01) * 0.8);
//}

// somewhat bearable
#define PI 3.1415
float noisySphere(in vec3 p, vec2 uv, float r) {
    vec3 pn = normalize(vec3(p.x, p.y, abs(p.z)));
    float u = pn.x / (1. + pn.z);
    float v = pn.y / (1. + pn.z);
    // vec4 color = texture(iChannel1, vec2(u, v));
    // vec4 color = texture(iChannel1, vec2(u, v));
    return (length (p) - r + (1. * 0.015));
}

// another version with triplanar possible only because sphere normals are trivial
// also requires path step decrease (by 0.7) on tracing step, because we are not able
// to return distance to the closest distorted part
float noisySphere(vec3 point, float radius) {
    vec3 normal = pow(abs(normalize(point)), vec3(1.));
    float multiplier = 5.;
    // float change = 
    //     normal.x * texture(iChannel1, point.yz * multiplier).r
    //     + normal.y * texture(iChannel1, point.xz * multiplier).r
    //     + normal.z * texture(iChannel1, point.xy * multiplier).r;
    float change = 0.1;
        
    return length(point) - radius - change * 0.017;
}

float smoothSubtraction ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );

    return mix( d2, -d1, h ) + k*h*(1.0-h); 
}


float smoothIntersection ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );

    return mix( d2, d1, h ) + k*h*(1.0-h); 
}
float sdf (in vec3 point, in vec2 uv, in mat3 matrix)
{
    // all points multiplied by affine matrix
    point = point * matrix;
    //return sphere(point, 0.2);
    //return noisySphere(point, uv, 0.16);
    //return noisySphere(point, 0.16);
    float d1 = box(point, vec3(0.14,0.14,0.14));
    //float d2 = noisySphere(point * rotateY(iTime/8.) * rotateX(iTime/8.), 0.161);
    //float d3 = noisySphere(point * rotateX(iTime/9.) * rotateZ(iTime/7.), 0.19);
    //float d2 = noisySphere(point, uv, 0.18 * ((abs(mod(iTime * 8., 20.)/10. - 1.)) * 0.3 + 0.6 ));
    float d2 = noisySphere(point * rotateY(uTime/8.) * rotateX(uTime/8.), uv, 0.171);
    float d3 = noisySphere(point * rotateX(uTime/9.) * rotateZ(uTime/7.), uv, 0.19);
    // return max(max(d1, -d2), d3);
    //return box(point, vec3(0.1, 1., 1.));
    return smoothIntersection(smoothSubtraction(d2, d1, 0.02), d3, 0.01);
    //float d2 = noisySphere(point * rotateY(iTime/10.) * rotateX(iTime/10.), uv, 0.18);
    //float d3 = noisySphere(point * rotateX(iTime/10.) * rotateZ(iTime/10.), uv, 0.19);
    //return smoothIntersection(-d2, d3, 0.02);
}

#define MAX_ITERS   80
#define MAX_DIST    50.0
vec3 trace (vec3 from, vec3 dir, vec2 uv, mat3 matrix, out bool hit, out int steps)
{
    vec3     p         = from;
    float    totalDist = 0.0;
    
    hit = false;
    
    for (steps = 0; steps < MAX_ITERS; steps++)
    {
        float dist = sdf(p, uv, matrix) * 0.7;
        
        if (dist < 0.0001)
        {
            hit = true;
            break;
        }
        
        totalDist += dist;
        
        if ( totalDist > MAX_DIST )
            break;
            
        p += dist * dir;
    }
    
    return p;
}

vec3 generateNormal ( vec3 surfacePoint, float d, vec2 uv, mat3 matrix )
{
    //float e   = max(d * 0.5, 0.001);
    
    float e = d;
    float dx1 = sdf(surfacePoint + vec3(e, 0, 0), uv, matrix);
    float dx2 = sdf(surfacePoint - vec3(e, 0, 0), uv, matrix);
    float dy1 = sdf(surfacePoint + vec3(0, e, 0), uv, matrix);
    float dy2 = sdf(surfacePoint - vec3(0, e, 0), uv, matrix);
    float dz1 = sdf(surfacePoint + vec3(0, 0, e), uv, matrix);
    float dz2 = sdf(surfacePoint - vec3(0, 0, e), uv, matrix);
  
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

void main()
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 resolution = vec2(1280, 720);
    // vec4 mouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);
    vec2 scale = resolution.xy / max(resolution.x, resolution.y);
    vec2 fragCoord = gl_GlobalInvocationID.xy;
    vec2 uv = (fragCoord/resolution.xy - vec2(0.5)) * scale;
    // mat3 matrix = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);
    mat3 matrix = rotateX (0.5) * rotateY (0.5);

    // Time varying pixel color
    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    bool hit;
    int  steps;
    vec3 camera = vec3(0., 0., 5.);
    // tracing direction
    vec3 direction = normalize ( vec3(uv, 0) - camera);
    vec3 intersectionPoint = trace (camera, direction, uv, matrix, hit, steps );
    
    vec3 lightSource = vec3  ( 5.0, 5.0, 8.0 ) * 2.;
    
    if (hit) {
        vec3 lightVector  = normalize ( lightSource - intersectionPoint );
        vec3 surfaceNormal  = generateNormal ( intersectionPoint, 0.001, uv, matrix );
        float diffuseLight = max( 0.01, dot ( surfaceNormal, lightVector ) ); 
        
        // blinn and phong
        vec3 viewVector = normalize(camera - intersectionPoint);
        vec3 halfwayVector = normalize(lightVector + viewVector);
        float specularLight = pow(max(dot(surfaceNormal, halfwayVector), 0.0), 10.);
        
        // vec3  tx = getTriplanarWeights ( surfaceNormal );
        // vec3  q  = 0.5 * intersectionPoint * matrix;
        // vec4  cx = texture ( iChannel2, q.yz );
        // vec4  cy = texture ( iChannel2, q.zx );
        // vec4  cz = texture ( iChannel2, q.xy );
        
        // fragColor = (diffuseLight + specularLight) * (tx.x * cx + tx.y + cy + tx.z * cz);
       
        vec4 color = vec4 ( 0.6, 0.7, 0.3, 1. ) * (diffuseLight + specularLight);
        imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), color);
    }
    else {
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

    // TODO: Put your shadertoy code here!
    // Simple gradient as a test.
    vec3 color = vec3(vec2(uv) / vec2(1280, 720), 0);

    if (uv.x < 1280 && uv.y < 720)
      imageStore(resultImage, uv, vec4(color, 1));
    }
}

// void main()
// {
//   ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

//   // TODO: Put your shadertoy code here!
//   // Simple gradient as a test.
//   vec3 color = vec3(vec2(uv) / vec2(1280, 720), 0);

//   if (uv.x < 1280 && uv.y < 720)
//     imageStore(resultImage, uv, vec4(color, 1));
// }